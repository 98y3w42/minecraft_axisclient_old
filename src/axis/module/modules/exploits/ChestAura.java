package axis.module.modules.exploits;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import axis.Axis;
import axis.command.Command;
import axis.event.Event.State;
import axis.event.events.UpdateEvent;
import axis.management.managers.ModuleManager.Category;
import axis.module.Module;
import axis.util.BlockHelper;
import axis.util.Logger;
import axis.util.TimeHelper;
import net.minecraft.block.Block;
import net.minecraft.block.BlockChest;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.inventory.GuiContainer;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.Vec3;

public class ChestAura extends Module {

	public static final List<BlockPos> openedBlocks = new CopyOnWriteArrayList();
	private final TimeHelper time = new TimeHelper();
	private boolean shouldBreak = false;
	BlockPos globalPos;

	public ChestAura() {
		super("ChestAura", 0x00FF00, Category.EXPLOITS);
		setTag("Chest KillAura");

		Axis.getCommandManager().getContents().add(new Command("chestauraclear", "none", new String[] { "clearchests", "cac" }) {
			public void run(String message) {
				ChestAura.openedBlocks.clear();
				Logger.logChat("Cleared Chest KillAura list!");
			}
		});
	}

	public void onUpdate(UpdateEvent event) {
		if (event.state == State.PRE) {
			if ((mc.currentScreen instanceof GuiContainer)) {
				this.time.reset();
			}
			int radius = 4;
			for (int y = radius; y >= -radius; y--) {
				for (int x = -radius; x <= radius; x++) {
					for (int z = -radius; z <= radius; z++) {
						BlockPos pos = new BlockPos(mc.thePlayer.posX - 0.5D + x,
								mc.thePlayer.posY - 0.5D + y,
								mc.thePlayer.posZ - 0.5D + z);
						Block block = Minecraft.getMinecraft().theWorld.getBlockState(pos).getBlock();
						if ((getFacingDirection(pos) != null) && (pos != null) && (!(mc.currentScreen instanceof GuiContainer))) {
							if ((mc.thePlayer.getDistance(mc.thePlayer.posX + x, mc.thePlayer.posY + y, mc.thePlayer.posZ + z) < mc.playerController.getBlockReachDistance() - 0.5D) && ((block instanceof BlockChest))) {
								this.shouldBreak = true;
								float[] rotations = BlockHelper.getBlockRotations(pos.getX(), pos.getY(), pos.getZ());
								event.yaw = rotations[0];
								event.pitch = rotations[1];
								this.globalPos = pos;
								return;
							}
						}
					}
				}
			}
		}

		if (event.state == State.POST) {
			if ((this.globalPos != null) && (!(mc.currentScreen instanceof GuiContainer)) && (!openedBlocks.contains(this.globalPos)) && (this.shouldBreak)) {
				mc.thePlayer.swingItem();
				if (mc.playerController.blockHitDelay > 1) {
					mc.playerController.blockHitDelay = 1;
				}
				EnumFacing direction = getFacingDirection(this.globalPos);
				if ((direction != null) &&
						(this.time.hasReached(400L))) {
					mc.playerController.onPlayerRightClick(mc.thePlayer, mc.theWorld, mc.thePlayer.getCurrentEquippedItem(), this.globalPos, direction,
							new Vec3(this.globalPos.getX(), this.globalPos.getY(), this.globalPos.getZ()));
					openedBlocks.add(this.globalPos);
					this.time.reset();
				}
			}
		}
	}

	public void onDisabled() {
		super.onDisabled();
		if (mc.theWorld != null) {
			openedBlocks.clear();
		}
	}

	private EnumFacing getFacingDirection(BlockPos pos) {
		EnumFacing direction = null;
		if (!mc.theWorld.getBlockState(pos.add(0, 1, 0)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.UP;
		} else if (!mc.theWorld.getBlockState(pos.add(0, -1, 0)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.DOWN;
		} else if (!mc.theWorld.getBlockState(pos.add(1, 0, 0)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.EAST;
		} else if (!mc.theWorld.getBlockState(pos.add(-1, 0, 0)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.WEST;
		} else if (!mc.theWorld.getBlockState(pos.add(0, 0, 1)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.SOUTH;
		} else if (!mc.theWorld.getBlockState(pos.add(0, 0, 1)).getBlock().isSolidFullCube()) {
			direction = EnumFacing.NORTH;
		}
		return direction;
	}

}
